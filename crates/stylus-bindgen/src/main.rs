use alloy_json_abi::JsonAbi;
use alloy_primitives::{U128, hex};
use clap::Parser;
use heck::ToSnakeCase;
use std::fs;
use std::path::PathBuf;

#[derive(Parser)]
struct Cli {
    #[arg(short, long)]
    input: PathBuf,

    #[arg(short, long)]
    output: PathBuf,
}

fn to_rust_type(sol_type: &str) -> String {
    match sol_type {
        "address" => "Address".to_string(),
        "uint256" => "U256".to_string(),
        "uint128" => "U128".to_string(),
        "bool" => "bool".to_string(),
        "bytes" => "Vec<u8>".to_string(),
        "bytes4" => "Vec<u8>".to_string(),
        "address[]" => "Vec<Address>".to_string(),
        "uint256[]" => "Vec<U256>".to_string(),
        "bool[]" => "Vec<bool>".to_string(),
        _ => unreachable!("unsupported Solidity type in ABI: {}", sol_type),
    }
}

fn main() -> anyhow::Result<()> {
    let args = Cli::parse();
    let content = fs::read_to_string(&args.input)?;
    let abi: JsonAbi = serde_json::from_str(&content)?;

    let mut code = String::new();

    code.push_str("// Generated by stylus-bindgen\n");
    code.push_str("#![allow(clippy::all)]\n");
    code.push_str("use stylus_sdk::{alloy_primitives::{Address, U256}, alloy_sol_types::SolType, call::RawCall, prelude::*};\n");
    code.push_str("\npub struct Contract {\n");
    code.push_str("    pub address: Address,\n");
    code.push_str("}\n\n");
    code.push_str("impl Contract {\n");
    code.push_str("    pub fn new(address: Address) -> Self { Self { address } }\n");

    for function in abi.functions() {
        let name = &function.name;
        let selector = hex::encode(function.selector());
        let safe_name = format!("{}__0x{}", name.to_snake_case(), selector);

        let inputs: Vec<String> = function
            .inputs
            .iter()
            .map(|input| format!("{}: {}", input.name, to_rust_type(&input.ty)))
            .collect();
        let input_args = inputs.join(", ");

        code.push_str(&format!("\n    // Original: {}\n", function.signature()));
        code.push_str(&format!(
            "    pub fn {}(&self, {}) -> Result<Vec<u8>, Vec<u8>> {{\n",
            safe_name, input_args
        ));

        code.push_str(&format!(
            "        let input = hex::decode(\"{}\").unwrap();\n",
            selector
        ));

        code.push_str(
            "        // note: real encoding requires SolType definitions (Milestone 2)\n",
        );

        code.push_str(
            "        let result = unsafe { RawCall::new_static().call(self.address, &input)? };\n",
        );
        code.push_str("        Ok(result)\n");
        code.push_str("    }\n");
    }

    code.push_str("}\n");

    fs::write(&args.output, code)?;
    println!("Generated bindings at: {:?}", args.output);

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::to_rust_type;

    #[test]
    fn to_rust_type_address() {
        assert_eq!(to_rust_type("address"), "Address");
    }

    #[test]
    fn to_rust_type_uint256() {
        assert_eq!(to_rust_type("uint256"), "U256");
    }

    #[test]
    fn to_rust_type_bool() {
        assert_eq!(to_rust_type("bool"), "bool");
    }

    #[test]
    fn to_rust_type_bytes() {
        assert_eq!(to_rust_type("bytes"), "Vec<u8>");
    }

    #[test]
    fn to_rust_type_bytes4() {
        assert_eq!(to_rust_type("bytes4"), "Vec<u8>");
    }

    #[test]
    fn to_rust_type_address_array() {
        assert_eq!(to_rust_type("address[]"), "Vec<Address>");
    }

    #[test]
    fn to_rust_type_uint256_array() {
        assert_eq!(to_rust_type("uint256[]"), "Vec<U256>");
    }

    #[test]
    fn to_rust_type_bool_array() {
        assert_eq!(to_rust_type("bool[]"), "Vec<bool>");
    }

    #[test]
    #[should_panic(expected = "unsupported Solidity type")]
    fn to_rust_type_unknown_panics() {
        to_rust_type("uint8");
    }
}
